see basically the logic is first read the question 852 of leetcode  Peak Index in a Mountain Array
Now elements below the peak index are in order(arr[0] < arr[1] < ... arr[i-1] < arr[i]) and elements after the peak index are in order(arr[i] > arr[i+1] > ... > arr[arr.length - 1])
So if our arr[mid]<arr[mid+1] then we are in increasing series and our peak lies on right so we can surely skip this elements.
if(arr[mid]>arr[mid+1]) then arr[mid] can be our ans so we do end=mid cause this index might be our answer..
now our termination condition will be low<high not low<=high as suppose start and end comes on same position then suppose if your terminating condition is
low<=high so again you will calculate mid and this time suppose arr[mid]>arr[mid+1] is true so end=mid and this will happen again and again resulting in infinite loop


now code..
    int peakIndexInMountainArray(vector<int>& arr) {
        int low=0,high=arr.size()-1;
        while(low<high)
        {
            int mid=(low+high)/2;
            if(arr[mid]>arr[mid+1])
            {
                high=mid;
            }
            else if(arr[mid]<arr[mid+1])
            low=mid+1;
        }
        return high;
    }
    
    in the end high will be our ans..
